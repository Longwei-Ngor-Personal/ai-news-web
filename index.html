<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>AI / Tech News Aggregator</title>
<style>
:root{color-scheme:light dark}
body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;margin:0;padding:1.2rem;max-width:980px;margin-inline:auto}
h1{font-size:1.5rem;margin:.2rem 0 .8rem}
.controls{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;margin-bottom:.6rem}
select,button{padding:.45rem .7rem;font-size:.95rem}
.status{font-size:.9rem;opacity:.75}
table{width:100%;border-collapse:collapse;margin-top:.6rem}
th,td{padding:.6rem;border-bottom:1px solid #ddd;text-align:left;vertical-align:top}
.feedlog{font-size:.85rem;opacity:.8;margin-top:.5rem;line-height:1.4}
.feedlog b{font-weight:600}
@media (prefers-color-scheme:dark){th,td{border-color:#333}}
</style>
</head>
<body>
<h1>ðŸ“° AI &amp; Tech News</h1>

<div class="controls">
  <label>Lookback
    <select id="hours">
      <option value="24">24h</option>
      <option value="48" selected>48h</option>
      <option value="72">72h</option>
      <option value="168">7d</option>
    </select>
  </label>
  <label>Show
    <select id="max">
      <option value="10">10</option>
      <option value="20" selected>20</option>
      <option value="30">30</option>
      <option value="50">50</option>
    </select>
  </label>
  <button id="fetchBtn">Fetch</button>
  <span id="status" class="status">idle</span>
</div>

<table id="newsTable">
  <thead>
    <tr><th style="width:52px">#</th><th>Title</th><th style="width:240px">Source</th><th style="width:120px">Date</th></tr>
  </thead>
  <tbody></tbody>
</table>

<div class="feedlog" id="feedlog"></div>

<script>
// === Add/edit your sources here ===
// (Many big outlets are paywalled; RSS headlines still work.)
const feeds = [
  // Core AI/tech
  { name: "OpenAI", url: "https://openai.com/news/rss.xml" },
  { name: "Google AI Blog", url: "https://ai.googleblog.com/feeds/posts/default" },
  { name: "Hugging Face", url: "https://huggingface.co/blog/feed.xml" },
  { name: "NVIDIA", url: "https://blogs.nvidia.com/blog/category/ai/feed/" },
  { name: "Microsoft Research", url: "https://www.microsoft.com/en-us/research/feed/" },
  { name: "TechCrunch AI", url: "https://techcrunch.com/tag/artificial-intelligence/feed/" },
  { name: "The Verge â€“ AI", url: "https://www.theverge.com/artificial-intelligence/rss/index.xml" },

  // Big outlets
  { name: "BBC Technology", url: "https://feeds.bbci.co.uk/news/technology/rss.xml" },
  { name: "NYT Technology", url: "https://rss.nytimes.com/services/xml/rss/nyt/Technology.xml" },
  { name: "WSJ Tech (WSJD)", url: "https://feeds.a.dj.com/rss/RSSWSJD.xml" },
  { name: "Wired AI", url: "https://www.wired.com/feed/tag/artificial-intelligence/latest/rss" },
  { name: "The Guardian â€“ AI", url: "https://www.theguardian.com/technology/artificial-intelligence/rss" }
];

// Multiple CORS-friendly proxies; weâ€™ll try in order per request.
const proxyFns = [
  (u)=>`https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
  (u)=>`https://cors.isomorphic-git.org/${u}`,
  (u)=>`https://thingproxy.freeboard.io/fetch/${encodeURIComponent(u)}`
];

const statusEl = document.getElementById("status");
const tbody    = document.querySelector("#newsTable tbody");
const hoursSel = document.getElementById("hours");
const maxSel   = document.getElementById("max");
const feedlog  = document.getElementById("feedlog");

// ---- Helpers ----
const escapeHtml = (s="") => s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
const dstr = (d) => d ? new Date(d).toISOString().slice(0,10) : "";
const tryParseDate = (text) => {
  const d = text ? new Date(text) : null;
  return isNaN(d?.getTime?.()) ? null : d;
};

function parseXML(xmlText, fallbackSource){
  const xml = new DOMParser().parseFromString(xmlText, "application/xml");
  if (xml.querySelector("parsererror")) throw new Error("XML parse error");
  const items = [];
  const sourceTitle = xml.querySelector("channel > title")?.textContent?.trim()
                    || xml.querySelector("feed > title")?.textContent?.trim()
                    || fallbackSource;

  // Atom
  xml.querySelectorAll("feed > entry").forEach(entry=>{
    const title = entry.querySelector("title")?.textContent?.trim() || "(untitled)";
    const linkEl = entry.querySelector("link[rel='alternate']") || entry.querySelector("link[href]");
    const link = linkEl?.getAttribute("href") || "";
    const dateText = entry.querySelector("updated, published")?.textContent || "";
    items.push({ title, url: link, source: sourceTitle, date: tryParseDate(dateText) });
  });

  // RSS
  xml.querySelectorAll("channel > item").forEach(item=>{
    const title = item.querySelector("title")?.textContent?.trim() || "(untitled)";
    const link = item.querySelector("link")?.textContent?.trim()
              || item.querySelector("guid")?.textContent?.trim() || "";
    const dateText = item.querySelector("pubDate")?.textContent
                  || item.querySelector("dc\\:date")?.textContent || "";
    items.push({ title, url: link, source: sourceTitle, date: tryParseDate(dateText) });
  });
  return items;
}

function withTimeout(ms, promise){
  const ctl = new AbortController();
  const t = setTimeout(()=>ctl.abort("timeout"), ms);
  return Promise.race([
    promise(ctl.signal).finally(()=>clearTimeout(t)),
    new Promise((_,rej)=>setTimeout(()=>rej(new Error("timeout")), ms+50))
  ]);
}

async function fetchViaProxies(url, timeoutMs=10000){
  let lastErr;
  for (const make of proxyFns){
    const proxied = make(url);
    try {
      const text = await withTimeout(timeoutMs, (signal)=> fetch(proxied, { signal }).then(r=>{
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return r.text();
      }));
      return text;
    } catch(e){ lastErr = e; }
  }
  throw lastErr || new Error("All proxies failed");
}

// Simple concurrency limiter (to avoid stampeding proxies)
async function pool(items, limit, worker){
  const ret = [];
  let i = 0, active = 0;
  return new Promise((resolve)=>{
    const next = () => {
      while (active < limit && i < items.length){
        const idx = i++; active++;
        worker(items[idx]).then((val)=> ret[idx]=val).catch((e)=> ret[idx]={error:String(e)}).finally(()=>{
          active--; (i===items.length && active===0) ? resolve(ret) : next();
        });
      }
    };
    next();
  });
}

// Local cache: key by hours+max; expire in 10 minutes
function cacheKey(hours, max){ return `aiNewsCache:${hours}:${max}`; }
function loadCache(hours, max){
  try{
    const raw = localStorage.getItem(cacheKey(hours,max));
    if (!raw) return null;
    const obj = JSON.parse(raw);
    if (Date.now() - obj.ts > 10*60*1000) return null; // 10 min
    return obj.items;
  }catch{ return null; }
}
function saveCache(hours, max, items){
  try{
    localStorage.setItem(cacheKey(hours,max), JSON.stringify({ts: Date.now(), items}));
  }catch{}
}

// ---- Main ----
async function fetchNews(){
  const hours = parseInt(hoursSel.value,10);
  const max   = parseInt(maxSel.value,10);
  const cutoff = Date.now() - hours*3600*1000;

  // Try cache first for instant paint
  const cached = loadCache(hours, max);
  if (cached) renderTable(cached, `(cached ${cached.length})`);

  statusEl.textContent = "loadingâ€¦";
  feedlog.innerHTML = "";
  const start = performance.now();

  // Fetch feeds in parallel with a small concurrency (e.g., 4)
  const results = await pool(feeds, 4, async (f)=>{
    try{
      const xmlText = await fetchViaProxies(f.url, 10000);
      const parsed = parseXML(xmlText, f.name).filter(it => !it.date || it.date.getTime() >= cutoff);
      return { ok: true, items: parsed, feed: f.name };
    }catch(e){
      return { ok: false, error: String(e), items: [], feed: f.name };
    }
  });

  const all = [];
  results.forEach(r=>{
    if (r.ok) {
      all.push(...r.items);
      feedlog.insertAdjacentHTML("beforeend", `<div><b>${escapeHtml(r.feed)}</b>: ok (${r.items.length})</div>`);
    } else {
      feedlog.insertAdjacentHTML("beforeend", `<div><b>${escapeHtml(r.feed)}</b>: fail (${escapeHtml(r.error)})</div>`);
    }
  });

  // Dedupe by URL+Title
  const seen = new Set();
  const uniq = all.filter(it=>{
    const key = (it.url||"")+"|"+(it.title||"");
    if (seen.has(key)) return false; seen.add(key); return true;
  });

  // Sort by date desc (undated last), cut to max
  uniq.sort((a,b)=>(b.date?.getTime?.()||0)-(a.date?.getTime?.()||0));
  const top = uniq.slice(0, max);

  // Cache for quick re-opens within 10 min
  saveCache(hours, max, top);

  renderTable(top, `ok (${top.length}) â€¢ ${(performance.now()-start|0)}ms`);
}

function renderTable(items, statusText="ok"){
  statusEl.textContent = statusText;
  tbody.innerHTML = "";
  if (!items.length){
    tbody.innerHTML = `<tr><td colspan="4">No news found. Try a longer lookback or click again in a moment.</td></tr>`;
    return;
  }
  items.forEach((it,i)=>{
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td>${i+1}</td>
      <td><a href="${it.url}" target="_blank" rel="noopener">${escapeHtml(it.title)}</a></td>
      <td>${escapeHtml(it.source||"")}</td>
      <td>${dstr(it.date)}</td>`;
    tbody.appendChild(tr);
  });
}

document.getElementById("fetchBtn").addEventListener("click", fetchNews);
fetchNews();
</script>
</body>
</html>
