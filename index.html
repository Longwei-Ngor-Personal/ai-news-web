<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>AI / Tech News Aggregator (AI-only)</title>
<style>
:root{color-scheme:light dark}
body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;margin:0;padding:1.2rem;max-width:980px;margin-inline:auto}
h1{font-size:1.5rem;margin:.2rem 0 .6rem}
.controls{display:grid;gap:.6rem;grid-template-columns:1fr}
.row{display:flex;gap:.6rem;flex-wrap:wrap;align-items:center}
select,button,input,textarea{padding:.45rem .6rem;font-size:.95rem}
textarea{min-height:62px;width:100%}
.status{font-size:.9rem;opacity:.75}
table{width:100%;border-collapse:collapse;margin-top:.8rem}
th,td{padding:.6rem;border-bottom:1px solid #ddd;text-align:left;vertical-align:top}
.feedlog{font-size:.85rem;opacity:.8;margin-top:.6rem;line-height:1.4}
.feedlog b{font-weight:600}
@media (prefers-color-scheme:dark){th,td{border-color:#333}}
.badge{display:inline-block;padding:.1rem .5rem;border-radius:999px;background:#eee}
@media (prefers-color-scheme:dark){.badge{background:#222}}
</style>
</head>
<body>
<h1>ðŸ§  AI-Only News</h1>

<div class="controls">
  <div class="row">
    <label>Lookback
      <select id="hours">
        <option value="24">24h</option>
        <option value="48" selected>48h</option>
        <option value="72">72h</option>
        <option value="168">7d</option>
      </select>
    </label>
    <label>Show
      <select id="max">
        <option value="10">10</option>
        <option value="20" selected>20</option>
        <option value="30">30</option>
        <option value="50">50</option>
      </select>
    </label>
    <button id="fetchBtn">Fetch</button>
    <span id="status" class="status badge">idle</span>
  </div>

  <label>Include keywords (comma-separated, match ANY)
    <textarea id="kwInclude">ai, artificial intelligence, machine learning, ml, deep learning, llm, large language model, generative, genai, gpt, chatgpt, openai, anthropic, claude, gemini, deepmind, llama, mistral, diffusion, transformer, rlhf, fine-tune, embeddings, vector db, retrieval, rag, prompt, safety, guardrails, alignment, multimodal</textarea>
  </label>

  <label>Exclude keywords (comma-separated, drop if ANY match)
    <textarea id="kwExclude">smartphone, iphone, android phone, gaming, console, netflix, disney+, crypto, bitcoin, ethereum, nft, spaceship, rocket launch, camera review, earbuds, headphones, foldable, wearable, social media drama, xitter, instagram, tiktok, snapchat</textarea>
  </label>
</div>

<table id="newsTable">
  <thead>
    <tr><th style="width:44px">#</th><th>Title</th><th style="width:240px">Source</th><th style="width:120px">Date</th></tr>
  </thead>
  <tbody></tbody>
</table>

<div class="feedlog" id="feedlog"></div>

<script>
// ---- Feeds (mix of AI-specific + general tech sections) ----
const feeds = [
  { name: "OpenAI", url: "https://openai.com/news/rss.xml" },
  { name: "Google AI Blog", url: "https://ai.googleblog.com/feeds/posts/default" },
  { name: "Hugging Face", url: "https://huggingface.co/blog/feed.xml" },
  { name: "NVIDIA", url: "https://blogs.nvidia.com/blog/category/ai/feed/" },
  { name: "Microsoft Research", url: "https://www.microsoft.com/en-us/research/feed/" },
  { name: "TechCrunch AI", url: "https://techcrunch.com/tag/artificial-intelligence/feed/" },
  { name: "The Verge â€“ AI", url: "https://www.theverge.com/artificial-intelligence/rss/index.xml" },

  // Big outlets (broader; keyword filter will narrow to AI)
  { name: "BBC Technology", url: "https://feeds.bbci.co.uk/news/technology/rss.xml" },
  { name: "NYT Technology", url: "https://rss.nytimes.com/services/xml/rss/nyt/Technology.xml" },
  { name: "WSJ Tech (WSJD)", url: "https://feeds.a.dj.com/rss/RSSWSJD.xml" },
  { name: "Wired AI", url: "https://www.wired.com/feed/tag/artificial-intelligence/latest/rss" },
  { name: "The Guardian â€“ AI", url: "https://www.theguardian.com/technology/artificial-intelligence/rss" }
];

// Proxies to bypass CORS (tried in order)
const proxyFns = [
  (u)=>`https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
  (u)=>`https://cors.isomorphic-git.org/${u}`,
  (u)=>`https://thingproxy.freeboard.io/fetch/${encodeURIComponent(u)}`
];

const statusEl = document.getElementById("status");
const tbody    = document.querySelector("#newsTable tbody");
const hoursSel = document.getElementById("hours");
const maxSel   = document.getElementById("max");
const feedlog  = document.getElementById("feedlog");
const kwIncEl  = document.getElementById("kwInclude");
const kwExcEl  = document.getElementById("kwExclude");

// ---- Helpers ----
const escapeHtml = (s="") => s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
const dstr = (d) => d ? new Date(d).toISOString().slice(0,10) : "";
const tryParseDate = (text) => {
  const d = text ? new Date(text) : null;
  return isNaN(d?.getTime?.()) ? null : d;
};

function parseXML(xmlText, fallbackSource){
  const xml = new DOMParser().parseFromString(xmlText, "application/xml");
  if (xml.querySelector("parsererror")) throw new Error("XML parse error");
  const items = [];
  const sourceTitle = xml.querySelector("channel > title")?.textContent?.trim()
                    || xml.querySelector("feed > title")?.textContent?.trim()
                    || fallbackSource;

  // Atom
  xml.querySelectorAll("feed > entry").forEach(entry=>{
    const title = entry.querySelector("title")?.textContent?.trim() || "(untitled)";
    const linkEl = entry.querySelector("link[rel='alternate']") || entry.querySelector("link[href]");
    const link = linkEl?.getAttribute("href") || "";
    const dateText = entry.querySelector("updated, published")?.textContent || "";
    // Try to extract summary/content for better keyword matching
    const summary = entry.querySelector("summary")?.textContent
                 || entry.querySelector("content")?.textContent
                 || "";
    items.push({ title, url: link, source: sourceTitle, date: tryParseDate(dateText), summary });
  });

  // RSS
  xml.querySelectorAll("channel > item").forEach(item=>{
    const title = item.querySelector("title")?.textContent?.trim() || "(untitled)";
    const link = item.querySelector("link")?.textContent?.trim()
              || item.querySelector("guid")?.textContent?.trim() || "";
    const dateText = item.querySelector("pubDate")?.textContent
                  || item.querySelector("dc\\:date")?.textContent || "";
    const summary = item.querySelector("description")?.textContent
                 || item.querySelector("content\\:encoded")?.textContent
                 || "";
    items.push({ title, url: link, source: sourceTitle, date: tryParseDate(dateText), summary });
  });
  return items;
}

function withTimeout(ms, promise){
  const ctl = new AbortController();
  const t = setTimeout(()=>ctl.abort("timeout"), ms);
  return Promise.race([
    promise(ctl.signal).finally(()=>clearTimeout(t)),
    new Promise((_,rej)=>setTimeout(()=>rej(new Error("timeout")), ms+50))
  ]);
}

async function fetchViaProxies(url, timeoutMs=10000){
  let lastErr;
  for (const make of proxyFns){
    const proxied = make(url);
    try {
      const text = await withTimeout(timeoutMs, (signal)=> fetch(proxied, { signal }).then(r=>{
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return r.text();
      }));
      return text;
    } catch(e){ lastErr = e; }
  }
  throw lastErr || new Error("All proxies failed");
}

// Concurrency limiter
async function pool(items, limit, worker){
  const ret = [];
  let i = 0, active = 0;
  return new Promise((resolve)=>{
    const next = () => {
      while (active < limit && i < items.length){
        const idx = i++; active++;
        worker(items[idx]).then((val)=> ret[idx]=val).catch((e)=> ret[idx]={error:String(e)}).finally(()=>{
          active--; (i===items.length && active===0) ? resolve(ret) : next();
        });
      }
    };
    next();
  });
}

// Keyword filtering (ANY include, NONE of exclude)
function parseList(raw){
  return (raw||"").split(",").map(s=>s.trim().toLowerCase()).filter(Boolean);
}
function isAIRelevant(item, includeList, excludeList){
  const hay = `${item.title} ${item.summary||""} ${item.source||""}`.toLowerCase();
  if (includeList.length && !includeList.some(k=>hay.includes(k))) return false;
  if (excludeList.length && excludeList.some(k=>hay.includes(k))) return false;
  return true;
}

// Cache (10 minutes)
function cacheKey(hours,max,inc,exc){ return `aiNewsCache:${hours}:${max}:${inc}:${exc}`; }
function loadCache(k){
  try{ const raw = localStorage.getItem(k); if(!raw) return null;
       const obj = JSON.parse(raw); if (Date.now()-obj.ts>10*60*1000) return null; return obj.items; }catch{ return null; }
}
function saveCache(k,items){ try{ localStorage.setItem(k, JSON.stringify({ts:Date.now(),items})); }catch{} }

// ---- Main ----
async function fetchNews(){
  const hours  = parseInt(hoursSel.value,10);
  const max    = parseInt(maxSel.value,10);
  const cutoff = Date.now() - hours*3600*1000;

  const incList = parseList(kwIncEl.value);
  const excList = parseList(kwExcEl.value);
  const ck = cacheKey(hours,max,incList.join("|"),excList.join("|"));

  // render from cache first
  const cached = loadCache(ck);
  if (cached) renderTable(cached, `(cached ${cached.length})`);

  statusEl.textContent = "loadingâ€¦";
  feedlog.innerHTML = "";
  tbody.innerHTML = "";
  const t0 = performance.now();

  const results = await pool(feeds, 4, async (f)=>{
    try{
      const xmlText = await fetchViaProxies(f.url, 10000);
      const parsed = parseXML(xmlText, f.name)
        .filter(it => !it.date || it.date.getTime() >= cutoff)
        .filter(it => isAIRelevant(it, incList, excList));
      return { ok:true, feed:f.name, items:parsed };
    }catch(e){
      return { ok:false, feed:f.name, error:String(e), items:[] };
    }
  });

  const all = [];
  results.forEach(r=>{
    if (r.ok){
      all.push(...r.items);
      feedlog.insertAdjacentHTML("beforeend", `<div><b>${escapeHtml(r.feed)}</b>: ok (${r.items.length})</div>`);
    }else{
      feedlog.insertAdjacentHTML("beforeend", `<div><b>${escapeHtml(r.feed)}</b>: fail (${escapeHtml(r.error)})</div>`);
    }
  });

  // dedupe by (url+title)
  const seen = new Set();
  const uniq = all.filter(it=>{
    const key = (it.url||"")+"|"+(it.title||"");
    if (seen.has(key)) return false; seen.add(key); return true;
  });

  uniq.sort((a,b)=>(b.date?.getTime?.()||0)-(a.date?.getTime?.()||0));
  const top = uniq.slice(0, max);

  saveCache(ck, top);
  renderTable(top, `ok (${top.length}) â€¢ ${(performance.now()-t0|0)}ms`);
}

function renderTable(items, statusText="ok"){
  statusEl.textContent = statusText;
  tbody.innerHTML = "";
  if (!items.length){
    tbody.innerHTML = `<tr><td colspan="4">No AI-relevant items for this window/keywords. Try widening lookback or adjusting filters.</td></tr>`;
    return;
  }
  items.forEach((it,i)=>{
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td>${i+1}</td>
      <td><a href="${it.url}" target="_blank" rel="noopener">${escapeHtml(it.title)}</a></td>
      <td>${escapeHtml(it.source||"")}</td>
      <td>${dstr(it.date)}</td>`;
    tbody.appendChild(tr);
  });
}

document.getElementById("fetchBtn").addEventListener("click", fetchNews);
fetchNews();
</script>
</body>
</html>
